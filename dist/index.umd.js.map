{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-member-accessibility */\nimport type { EventEmitter } from 'events';\n\n/**\n * A filter for an EventIterator.\n */\nexport type EventIteratorFilter<V> = (value: V) => boolean;\n\n/**\n * Options to be passed to an EventIterator.\n */\nexport interface EventIteratorOptions<V> {\n\t/**\n\t * The filter.\n\t */\n\tfilter?: EventIteratorFilter<V>;\n\n\t/**\n\t * The timeout in ms before ending the EventIterator.\n\t */\n\tidle?: number;\n\n\t/**\n\t * The limit of events that pass the filter to iterate.\n\t */\n\tlimit?: number;\n}\n\n/**\n * An EventIterator, used for asynchronously iterating over received values.\n */\nexport class EventIterator<V extends unknown[]> implements AsyncIterableIterator<V> {\n\t/**\n\t * The emitter to listen to.\n\t */\n\tpublic readonly emitter: EventEmitter;\n\n\t/**\n\t * The event the event iterator is listening for to receive values from.\n\t */\n\tpublic readonly event: string;\n\n\t/**\n\t * The filter used to filter out values.\n\t */\n\tpublic filter: EventIteratorFilter<V>;\n\n\t/**\n\t * Whether or not the EventIterator has ended.\n\t */\n\t#ended = false;\n\n\t/**\n\t * The amount of idle time in ms before moving on.\n\t */\n\t#idle?: number;\n\n\t/**\n\t * The queue of received values.\n\t */\n\t#queue: V[] = [];\n\n\t/**\n\t * The amount of events that have passed the filter.\n\t */\n\t#passed = 0;\n\n\t/**\n\t * The limit before ending the EventIterator.\n\t */\n\t#limit: number;\n\n\t/**\n\t * The timer to track when this will idle out.\n\t */\n\t#idleTimer: NodeJS.Timer | null = null;\n\n\t/**\n\t * The push handler with context bound to the instance.\n\t */\n\t#push: (this: EventIterator<V>, ...value: V) => void;\n\n\t/**\n\t * @param emitter The event emitter to listen to.\n\t * @param event The event we're listening for to receives values from.\n\t * @param limit The amount of values to receive before ending the iterator.\n\t * @param options Any extra options.\n\t */\n\tpublic constructor(emitter: EventEmitter, event: string, options: EventIteratorOptions<V> = {}) {\n\t\tthis.emitter = emitter;\n\t\tthis.event = event;\n\t\tthis.#limit = options.limit ?? Infinity;\n\t\tthis.#idle = options.idle;\n\t\tthis.filter = options.filter ?? ((): boolean => true);\n\n\t\t// This timer is to idle out on lack of valid responses\n\t\tif (this.#idle) this.#idleTimer = setTimeout(this.end.bind(this), this.#idle);\n\n\t\t// @ts-expect-error Silence weird compiler issue regarding `this.push`'s arguments not being `any`.\n\t\tthis.#push = this.push.bind(this);\n\t\tconst maxListeners = this.emitter.getMaxListeners();\n\t\tif (maxListeners !== 0) this.emitter.setMaxListeners(maxListeners + 1);\n\n\t\t// @ts-expect-error Silence weird compiler issue regarding `this.push`'s arguments not being `any`.\n\t\tthis.emitter.on(this.event, this.#push);\n\t}\n\n\t/**\n\t * Whether or not the EventIterator has ended.\n\t */\n\tpublic get ended(): boolean {\n\t\treturn this.#ended;\n\t}\n\n\t/**\n\t * Ends the EventIterator.\n\t */\n\tpublic end(): void {\n\t\tif (this.#ended) return;\n\t\tthis.#ended = true;\n\t\tthis.#queue = [];\n\n\t\t// @ts-expect-error Silence weird compiler issue regarding `this.push`'s arguments not being `any`.\n\t\tthis.emitter.off(this.event, this.#push);\n\t\tconst maxListeners = this.emitter.getMaxListeners();\n\t\tif (maxListeners !== 0) this.emitter.setMaxListeners(maxListeners - 1);\n\t}\n\n\t/**\n\t * The next value that's received from the EventEmitter.\n\t */\n\tpublic async next(): Promise<IteratorResult<V>> {\n\t\t// If there are elements in the queue, return an undone response:\n\t\tif (this.#queue.length) {\n\t\t\tconst value = this.#queue.shift()!;\n\t\t\tif (!this.filter(value)) return this.next();\n\t\t\tif (++this.#passed >= this.#limit) this.end();\n\t\t\tif (this.#idleTimer) this.#idleTimer.refresh();\n\t\t\treturn { done: false, value };\n\t\t}\n\n\t\t// If the iterator ended, clean-up timer and return a done response:\n\t\tif (this.#ended) {\n\t\t\tif (this.#idleTimer) clearTimeout(this.#idleTimer);\n\t\t\treturn { done: true, value: undefined as never };\n\t\t}\n\n\t\t// Listen for a new element from the emitter:\n\t\treturn new Promise<IteratorResult<V>>((resolve) => {\n\t\t\tlet idleTimer: NodeJS.Timer | null = null;\n\n\t\t\t// If there is an idle time set, we will create a temporary timer,\n\t\t\t// which will cause the iterator to end if no new elements are received:\n\t\t\tif (this.#idle) {\n\t\t\t\tidleTimer = setTimeout(() => {\n\t\t\t\t\tthis.end();\n\t\t\t\t\tresolve(this.next());\n\t\t\t\t}, this.#idle);\n\t\t\t}\n\n\t\t\t// Once it has received at least one value, we will clear the timer (if defined),\n\t\t\t// and resolve with the new value:\n\t\t\tthis.emitter.once(this.event, () => {\n\t\t\t\tif (idleTimer) clearTimeout(idleTimer);\n\t\t\t\tresolve(this.next());\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Handles what happens when you break or return from a loop.\n\t */\n\tpublic return(): Promise<IteratorResult<V>> {\n\t\tthis.end();\n\t\treturn Promise.resolve({ done: true, value: undefined as never });\n\t}\n\n\t/**\n\t * Handles what happens when you encounter an error in a loop.\n\t */\n\tpublic throw(): Promise<IteratorResult<V>> {\n\t\tthis.end();\n\t\treturn Promise.resolve({ done: true, value: undefined as never });\n\t}\n\n\t/**\n\t * The symbol allowing EventIterators to be used in for-await-of loops.\n\t */\n\tpublic [Symbol.asyncIterator](): AsyncIterableIterator<V> {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pushes a value into the queue.\n\t */\n\tprotected push(...value: V): void {\n\t\tthis.#queue.push(value);\n\t}\n}\n"],"names":["EventIterator","[object Object]","emitter","event","options","Object","_ended","_idle","_queue","_passed","_limit","_idleTimer","_push","this","__classPrivateFieldSet","limit","Infinity","idle","filter","setTimeout","end","bind","push","maxListeners","getMaxListeners","setMaxListeners","on","ended","off","__classPrivateFieldGet","length","value","shift","refresh","done","next","clearTimeout","undefined","Promise","resolve","idleTimer","once","Symbol","asyncIterator"],"mappings":"igBA+BaA,cAyDZC,YAAmBC,EAAuBC,EAAeC,EAAmC,IArD5FC,+FAKAA,6FAKAA,8FAKAC,YAAS,GAKTC,mBAKAC,WAAc,IAKdC,WAAU,GAKVC,mBAKAC,WAAkC,MAKlCC,mBASCC,KAAKX,QAAUA,EACfW,KAAKV,MAAQA,EACbW,EAAAD,OAAcT,EAAQW,OAASC,EAAAA,GAC/BF,EAAAD,OAAaT,EAAQa,MACrBJ,KAAKK,OAASd,EAAQc,cAA0B,cAGhCJ,EAAAD,OAAkBM,WAAWN,KAAKO,IAAIC,KAAKR,kBAG3DC,EAAAD,OAAaA,KAAKS,KAAKD,KAAKR,OAC5B,MAAMU,EAAeV,KAAKX,QAAQsB,kBACb,IAAjBD,GAAoBV,KAAKX,QAAQuB,gBAAgBF,EAAe,GAGpEV,KAAKX,QAAQwB,GAAGb,KAAKV,iBAMtBwB,YACC,iBAMM1B,MACN,aAAiB,OACjBa,EAAAD,QAAc,GACdC,EAAAD,OAAc,IAGdA,KAAKX,QAAQ0B,IAAIf,KAAKV,iBACtB,MAAMoB,EAAeV,KAAKX,QAAQsB,kBACb,IAAjBD,GAAoBV,KAAKX,QAAQuB,gBAAgBF,EAAe,GAM9DtB,aAEN,GAAI4B,UAAYC,OAAQ,CACvB,MAAMC,EAAQF,UAAYG,QAC1B,OAAKnB,KAAKK,OAAOa,IACbjB,mCAA+BD,KAAKO,iBACnBS,UAAgBI,UAC9B,CAAEC,MAAM,EAAOH,MAAAA,IAHUlB,KAAKsB,OAOtC,6BACsBC,wBACd,CAAEF,MAAM,EAAMH,WAAOM,IAItB,IAAIC,SAA4BC,IACtC,IAAIC,EAAiC,iBAKpCA,EAAYrB,YAAW,KACtBN,KAAKO,MACLmB,EAAQ1B,KAAKsB,sBAMftB,KAAKX,QAAQuC,KAAK5B,KAAKV,OAAO,KACzBqC,GAAWJ,aAAaI,GAC5BD,EAAQ1B,KAAKsB,cAQTlC,SAEN,OADAY,KAAKO,MACEkB,QAAQC,QAAQ,CAAEL,MAAM,EAAMH,WAAOM,IAMtCpC,QAEN,OADAY,KAAKO,MACEkB,QAAQC,QAAQ,CAAEL,MAAM,EAAMH,WAAOM,IAMtCpC,oGAACyC,OAAOC,kBACd,OAAO9B,KAMEZ,QAAQ8B,GACjBF,UAAYP,KAAKS"}